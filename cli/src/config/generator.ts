import { mkdirSync, existsSync, writeFileSync } from "node:fs";
import { join, dirname } from "node:path";
import type { DetectionResult } from "../detectors/types.js";

/**
 * Configuration for the generated config file
 */
export interface GeneratedConfig {
  project: {
    name: string;
    language: string;
    framework?: string;
  };
  commands: {
    test?: string;
    lint?: string;
    build?: string;
  };
  rules: string[];
}

/**
 * Result of writing a config file
 */
export interface WriteConfigResult {
  success: boolean;
  path: string;
  overwritten: boolean;
  error?: string;
}

/**
 * Convert a DetectionResult to a GeneratedConfig
 */
export function detectionToConfig(result: DetectionResult): GeneratedConfig | null {
  if (!result.detected || !result.project) {
    return null;
  }

  const config: GeneratedConfig = {
    project: {
      name: result.project.name,
      language: result.project.language,
    },
    commands: {},
    rules: [],
  };

  // Add framework if detected
  if (result.project.framework) {
    config.project.framework = result.project.framework;
  }

  // Add commands if present
  if (result.commands) {
    if (result.commands.test) {
      config.commands.test = result.commands.test;
    }
    if (result.commands.lint) {
      config.commands.lint = result.commands.lint;
    }
    if (result.commands.build) {
      config.commands.build = result.commands.build;
    }
  }

  return config;
}

/**
 * Generate YAML string from a GeneratedConfig
 * Note: Simple YAML generator - no external dependencies
 */
export function configToYaml(config: GeneratedConfig): string {
  const lines: string[] = [];

  // Header comment
  lines.push("# .ralph/config.yaml (generated by sfs --init)");
  lines.push("");

  // Project section
  lines.push("project:");
  lines.push(`  name: ${yamlEscape(config.project.name)}`);
  lines.push(`  language: ${config.project.language}`);
  if (config.project.framework) {
    lines.push(`  framework: ${config.project.framework}`);
  }

  // Commands section
  lines.push("");
  lines.push("commands:");
  if (config.commands.test) {
    lines.push(`  test: ${yamlEscape(config.commands.test)}`);
  }
  if (config.commands.lint) {
    lines.push(`  lint: ${yamlEscape(config.commands.lint)}`);
  }
  if (config.commands.build) {
    lines.push(`  build: ${yamlEscape(config.commands.build)}`);
  }

  // If no commands, add a comment
  if (!config.commands.test && !config.commands.lint && !config.commands.build) {
    lines.push("  # No commands detected - add manually");
  }

  // Rules section
  lines.push("");
  lines.push("# Add project-specific rules below:");
  lines.push("rules: []");
  lines.push("");

  return lines.join("\n");
}

/**
 * Escape a string for YAML output
 * Quotes the string if it contains special characters
 */
export function yamlEscape(value: string): string {
  // If value is empty, use empty quotes
  if (!value) {
    return '""';
  }

  // Check if quoting is needed
  const needsQuotes =
    // Starts with special chars
    /^[&*!|>'"%@`[\]{},?#-]/.test(value) ||
    // Contains colon followed by space
    value.includes(": ") ||
    // Starts or ends with whitespace
    /^\s|\s$/.test(value) ||
    // Contains newlines
    value.includes("\n") ||
    // Contains backslashes
    value.includes("\\") ||
    // Contains quotes
    value.includes('"') ||
    value.includes("'") ||
    // Is a YAML keyword
    ["true", "false", "null", "yes", "no", "on", "off"].includes(value.toLowerCase());

  if (!needsQuotes) {
    return value;
  }

  // Use double quotes, escaping internal double quotes and backslashes
  const escaped = value
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"')
    .replace(/\n/g, "\\n");

  return `"${escaped}"`;
}

/**
 * Get the default config file path for a project
 */
export function getConfigPath(projectPath: string): string {
  return join(projectPath, ".ralph", "config.yaml");
}

/**
 * Check if a config file already exists
 */
export function configExists(projectPath: string): boolean {
  return existsSync(getConfigPath(projectPath));
}

/**
 * Write a generated config to the file system
 * @param projectPath - Project root directory
 * @param config - Configuration to write
 * @param overwrite - If true, overwrite existing file without checking
 */
export function writeConfig(
  projectPath: string,
  config: GeneratedConfig,
  overwrite = false
): WriteConfigResult {
  const configPath = getConfigPath(projectPath);
  const configDir = dirname(configPath);
  const exists = existsSync(configPath);

  if (exists && !overwrite) {
    return {
      success: false,
      path: configPath,
      overwritten: false,
      error: "Config file already exists. Use --force to overwrite.",
    };
  }

  try {
    // Create .ralph directory if it doesn't exist
    if (!existsSync(configDir)) {
      mkdirSync(configDir, { recursive: true });
    }

    // Generate and write YAML
    const yaml = configToYaml(config);
    writeFileSync(configPath, yaml, "utf-8");

    return {
      success: true,
      path: configPath,
      overwritten: exists,
    };
  } catch (error) {
    return {
      success: false,
      path: configPath,
      overwritten: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Generate config from detection result and write to file
 * Convenience function that combines detection -> config -> YAML -> write
 */
export function generateAndWriteConfig(
  projectPath: string,
  detectionResult: DetectionResult,
  overwrite = false
): WriteConfigResult {
  const config = detectionToConfig(detectionResult);

  if (!config) {
    return {
      success: false,
      path: getConfigPath(projectPath),
      overwritten: false,
      error: "Could not generate config: detection result is invalid or empty",
    };
  }

  return writeConfig(projectPath, config, overwrite);
}
